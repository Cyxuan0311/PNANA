#include "features/recent_files_manager.h"
#include <algorithm>
#include <filesystem>
#include <fstream>

namespace pnana {
namespace features {

RecentFilesManager::RecentFilesManager() {
    loadRecentFiles();
}

void RecentFilesManager::addFile(const std::string& filepath) {
    if (filepath.empty()) {
        return;
    }

    // 移除重复文件（如果存在）
    removeDuplicates(filepath);

    // 添加到队列前端
    recent_files_.push_front(filepath);

    // 保持最大数量限制
    if (recent_files_.size() > MAX_RECENT_FILES) {
        recent_files_.pop_back();
    }

    // 保存到文件
    saveRecentFiles();
}

std::vector<std::string> RecentFilesManager::getRecentFiles() const {
    return std::vector<std::string>(recent_files_.begin(), recent_files_.end());
}

bool RecentFilesManager::isFileRecent(const std::string& filepath) const {
    return std::find(recent_files_.begin(), recent_files_.end(), filepath) != recent_files_.end();
}

void RecentFilesManager::clearRecentFiles() {
    recent_files_.clear();
}

size_t RecentFilesManager::getRecentFilesCount() const {
    return recent_files_.size();
}

void RecentFilesManager::setFileOpenCallback(std::function<void(const std::string&)> callback) {
    file_open_callback_ = callback;
}

void RecentFilesManager::openFile(size_t index) {
    if (index < recent_files_.size() && file_open_callback_) {
        file_open_callback_(recent_files_[index]);
    }
}

void RecentFilesManager::removeDuplicates(const std::string& filepath) {
    auto it = std::find(recent_files_.begin(), recent_files_.end(), filepath);
    if (it != recent_files_.end()) {
        recent_files_.erase(it);
    }
}

void RecentFilesManager::loadRecentFiles() {
    try {
        std::filesystem::path config_dir = getConfigDir();
        std::filesystem::path recent_file_path = config_dir / "recent_files.txt";

        if (!std::filesystem::exists(recent_file_path)) {
            return;
        }

        std::ifstream file(recent_file_path);
        if (!file.is_open()) {
            return;
        }

        recent_files_.clear();
        std::string line;
        while (std::getline(file, line)) {
            // 跳过空行和注释行
            if (line.empty() || line[0] == '#') {
                continue;
            }

            // 检查文件是否仍然存在
            if (std::filesystem::exists(line)) {
                recent_files_.push_back(line);
            }

            // 限制数量
            if (recent_files_.size() >= MAX_RECENT_FILES) {
                break;
            }
        }

        file.close();
    } catch (...) {
        // 忽略加载错误，使用空的最近文件列表
    }
}

void RecentFilesManager::saveRecentFiles() {
    try {
        std::filesystem::path config_dir = getConfigDir();

        // 确保配置目录存在
        std::filesystem::create_directories(config_dir);

        std::filesystem::path recent_file_path = config_dir / "recent_files.txt";
        std::ofstream file(recent_file_path);

        if (!file.is_open()) {
            return;
        }

        // 写入文件头注释
        file << "# Recent files list for pnana editor" << std::endl;
        file << "# This file is automatically generated, do not edit manually" << std::endl;
        file << std::endl;

        // 写入文件路径
        for (const auto& filepath : recent_files_) {
            file << filepath << std::endl;
        }

        file.close();
    } catch (...) {
        // 忽略保存错误
    }
}

std::filesystem::path RecentFilesManager::getConfigDir() const {
    const char* home = std::getenv("HOME");
    if (!home) {
        // 如果无法获取HOME，使用当前目录
        return std::filesystem::current_path() / ".pnana";
    }

    return std::filesystem::path(home) / ".config" / "pnana";
}

} // namespace features
} // namespace pnana
